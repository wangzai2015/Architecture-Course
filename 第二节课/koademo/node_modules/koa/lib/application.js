
'use strict';

/**
 * Module dependencies.
 */

//const isGeneratorFunction = require('is-generator-function');
//const debug = require('debug')('koa:application');
//const onFinished = require('on-finished');
const response = require('./response');
//const compose = require('koa-compose');
//const isJSON = require('koa-is-json');
const context = require('./context');
const request = require('./request');
//const statuses = require('statuses');
//const Cookies = require('cookies');
//const accepts = require('accepts');
const Emitter = require('events');
const assert = require('assert');
const Stream = require('stream');
const http = require('http');
const url = require('url');
//const only = require('only');
//const convert = require('koa-convert');
//const deprecate = require('depd')('koa');

/**
 * Expose `Application` class.
 * Inherits from `Emitter.prototype`.
 */

module.exports = class Application extends Emitter {

  /**
   * Initialize a new `Application`.
   *
   * @api public
   */

  constructor() {
    super();
    this.proxy = false;
    this.middleware = [];
    this.subdomainOffset = 2;
    this.env = process.env.NODE_ENV || 'development';
    //this.context = Object.create(context);
    //this.request = Object.create(request);
    //this.response = Object.create(response);
  }

  /**
   * Shorthand for:
   *
   *    http.createServer(app.callback()).listen(...)
   *
   * @param {Mixed} ...
   * @return {Server}
   * @api public
   */

  listen() {
    //debug('listen');
    const server = http.createServer(this.callback());
    return server.listen.apply(server, arguments);
  }

  /**
   * Return JSON representation.
   * We only bother showing settings.
   *
   * @return {Object}
   * @api public
   */

  toJSON() {
   /* return only(this, [
      'subdomainOffset',
      'proxy',
      'env'
    ]);*/
 return 'only';
  }

  /**
   * Inspect implementation.
   *
   * @return {Object}
   * @api public
   */

  inspect() {
    return this.toJSON();
  }

  /**
   * Use the given middleware `fn`.
   *
   * Old-style middleware will be converted.
   *
   * @param {Function} fn
   * @return {Application} self
   * @api public
   */

  use(fn) {
    this.middleware.push(fn);
    return this;
  }

  /**
   * Return a request handler callback
   * for node's native http server.
   *
   * @return {Function}
   * @api public
   */

  callback() {
    //const fn = compose(this.middleware);

    //if (!this.listeners('error').length) this.on('error', this.onerror);

    return (req, res) => {
      res.statusCode = 404;
      // const ctx = this.createContext(req, res);
     // onFinished(res, ctx.onerror);
      //fn(ctx).then(() => respond(ctx)).catch(ctx.onerror);
      //res.body = 'wangnn 3';

    // TODO ctx
      let ctx = {};
      ctx.req = req;
      ctx.res = res;
      ctx.response = req;
      ctx.request = res;
      ctx.path = url.parse(req.url).pathname;
      ctx.method = req.method;

      const fn = this.compose(this.middleware, this);
          console.log(fn)
      fn.then(() => {
        // TODO 其他数据类型
        let body = ctx.body;
     console.log(body)

        if (ctx.res.headersSent) {
          res.end();
        } else {
          res.statusCode = 200;
        }
        if (body === undefined) {
          res.statusCode = 404;
        }

        if (body instanceof Stream) {
          return body.pipe(res);
        }

        if (typeof body !== 'string') {
          body = JSON.stringify(body);
        }
        res.end(body || 'not found');
      }).catch(err => {
        console.log(err);
        res.end('gogogo');
      })

     /* console.log(res)
      res.end(res.body);*/
    };

  }

//返回数组类函数
  compose (context, that, next) {
    // last called middleware #
    let index = -1
    return dispatch(0)
    function dispatch (i) {
      index = i
      let fn =that.middleware[i]
      if (i === that.middleware.length) fn = next
      if (!fn) return Promise.resolve()
      try {
        return Promise.resolve(fn(context, function next () {
          return dispatch(i + 1)
        }))
      } catch (err) {
        return Promise.reject(err)
      }
    }
  }

  /**
   * Initialize a new context.
   *
   * @api private
   */

  // createContext(req, res) {
  //   const context = Object.create(this.context);
  //   const request = context.request = Object.create(this.request);
  //   const response = context.response = Object.create(this.response);
  //   context.app = request.app = response.app = this;
  //   context.req = request.req = response.req = req;
  //   context.res = request.res = response.res = res;
  //   request.ctx = response.ctx = context;
  //   request.response = response;
  //   response.request = request;
  //   context.onerror = context.onerror.bind(context);
  //   context.originalUrl = request.originalUrl = req.url;
  //   /*context.cookies = new Cookies(req, res, {
  //     keys: this.keys,
  //     secure: request.secure
  //   });*/
  //   context.cookies = new Cookies(req, res, {
  //     keys: "cookiesKey",
  //     secure: "cookiesSecure"
  //   });
  //   //context.accept = request.accept = accepts(req);
  //    context.accept = request.accept = "accepts(req)";
  //   context.state = {};
  //   return context;
  // }

  /**
   * Default error handler.
   *
   * @param {Error} err
   * @api private
   */

  // onerror(err) {
  //   assert(err instanceof Error, `non-error thrown: ${err}`);

  //   if (404 == err.status || err.expose) return;
  //   if (this.silent) return;

  //   const msg = err.stack || err.toString();
  //   console.error();
  //   console.error(msg.replace(/^/gm, '  '));
  //   console.error();
  // }

};

/**
 * Response helper.
 */

// function respond(ctx) {
//   // allow bypassing koa
//   if (false === ctx.respond) return;

//   const res = ctx.res;
//   if (!ctx.writable) return;

//   let body = ctx.body;
//   const code = ctx.status;

//   // ignore body
//   if (statuses.empty[code]) {
//     // strip headers
//     ctx.body = null;
//     return res.end();
//   }

//   if ('HEAD' == ctx.method) {
//     /*if (!res.headersSent && isJSON(body)) {
//       ctx.length = Buffer.byteLength(JSON.stringify(body));
//     }*/
//       ctx.length = Buffer.byteLength(JSON.stringify(body));
//     return res.end();
//   }

//   // status body
//   if (null == body) {
//     body = ctx.message || String(code);
//     if (!res.headersSent) {
//       ctx.type = 'text';
//       ctx.length = Buffer.byteLength(body);
//     }
//     return res.end(body);
//   }

//   // responses
//   if (Buffer.isBuffer(body)) return res.end(body);
//   if ('string' == typeof body) return res.end(body);
//   if (body instanceof Stream) return body.pipe(res);

//   // body: json
//   body = JSON.stringify(body);
//   if (!res.headersSent) {
//     ctx.length = Buffer.byteLength(body);
//   }
//   res.end(body);
// }
